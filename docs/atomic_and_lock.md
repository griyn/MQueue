# 原子变量和锁
* 粒度：原子变量比锁的粒度更小。原子变量只是用来保证单个变量的原子性操作，而锁是用来保护一段代码块的访问，需要加锁和解锁。
* 阻塞性：锁是一种阻塞性的同步机制，即如果某个线程获取了锁，其他线程就必须等待锁的释放才能继续执行。而原子变量操作不会阻塞其他线程，它们会以非阻塞的方式尝试访问共享资源，如果失败就会立即返回。
* 开销：原子变量的开销比锁要小。因为原子操作只需要对单个变量进行操作，而锁需要额外的开销来管理锁的状态和线程的等待。原子操作通常由硬件提供支持，如x86架构的处理器具有x86架构的原子指令，这些指令可以在用户态执行而无需进入内核态。因此，在使用x86架构的处理器上，原子变量操作通常不需要进入内核态；互斥锁操作一定会使进程陷入内核态（自旋锁不会进入内核态，它是纯软件实现）。
* 应用场景：原子变量通常用于一些简单的、不需要复杂的同步机制的场景，例如计数器、标志等。而锁则用于需要严格同步的场景，例如临界区的保护、资源分配等。
